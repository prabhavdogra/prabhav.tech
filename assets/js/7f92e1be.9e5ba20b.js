"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4652],{3637:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=t(4839),i=t(4848),r=t(8453);const o={slug:"atomic_operations",title:"How Go atomic operations avoid race conditions?",authors:["prabhavdogra"],tags:["go"]},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:3},{value:"Go Code Structure",id:"go-code-structure",level:3},{value:"What&#39;s Go Assembly?",id:"whats-go-assembly",level:3},{value:"Conclusion",id:"conclusion",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["This question popped up in my head, ",(0,i.jsx)(n.em,{children:'"How Go atomic operations avoid race conditions?"'})]}),"\n",(0,i.jsxs)(n.p,{children:["I finally gathered the courage to open the cloned ",(0,i.jsx)(n.a,{href:"https://github.com/golang/go",children:"Go Github repo"})," and scan through it."]}),"\n",(0,i.jsx)(n.h3,{id:"go-code-structure",children:"Go Code Structure"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Go code structure",src:t(6752).A+"",width:"614",height:"491"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Source: ChatGPT"})}),"\n",(0,i.jsxs)(n.p,{children:["I went inside the implementation of ",(0,i.jsx)(n.code,{children:"CompareAndSwapInt32"})," and found this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="src/sync/atomic/doc.go"',children:"// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n// Consider using the more ergonomic and less error-prone [Int32.CompareAndSwap] instead.\n//\n//go:noescape\nfunc CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finding the implementation of this was not straightforward, because this method is implemented in Go Assembly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="src/sync/atomic/asm.s"',children:"TEXT \xb7CompareAndSwapInt32(SB),NOSPLIT,$0\n\tJMP\tinternal\u2215runtime\u2215atomic\xb7Cas(SB)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"whats-go-assembly",children:"What's Go Assembly?"}),"\n",(0,i.jsxs)(n.p,{children:["Simply put, ",(0,i.jsx)(n.strong,{children:"Go Assembly"})," is the low-level language used to write performance-critical functions in Go.\n",(0,i.jsx)(n.strong,{children:"Go Assembler"})," (Code directory path: cmd/asm) is the tool that compiles ",(0,i.jsx)(n.strong,{children:"Go assembly (.s) files"})," into machine code.\nThe Go assembler was heavily inspired by the ",(0,i.jsx)(n.a,{href:"https://9p.io/sys/doc/compiler.html",children:"Plan 9 C compilers"}),"."]}),"\n",(0,i.jsxs)(n.admonition,{title:"Plan 9 C compilers",type:"note",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Plan 9 C compilers (6c, 8c, 5c, etc.)"})," were architecture-specific compilers designed to generate optimized code for different CPU architectures. Unlike GCC or LLVM, which support multiple architectures within a single compiler framework, Plan 9 used separate compilers for different instruction sets. These compilers were originally developed for the Plan 9 operating system, an experimental OS designed as a potential successor to Unix-based systems."]}),(0,i.jsxs)(n.p,{children:["You can read more about it here: ",(0,i.jsx)(n.a,{href:"https://9p.io/sys/doc/compiler.html",children:"https://9p.io/sys/doc/compiler.html"})]})]}),"\n",(0,i.jsx)(n.p,{children:"Go drew inspiration from 9 C Compiler:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Just like ",(0,i.jsx)(n.strong,{children:"Plan 9"})," had ",(0,i.jsx)(n.strong,{children:"separate compilers"})," for ",(0,i.jsx)(n.strong,{children:"different architectures"})," (e.g., 6c for x86-64, 8c for ARM, etc.)."]}),"\n",(0,i.jsx)(n.li,{children:"Go\u2019s assembler follows a similar architecture-based approach, instead of a universal assembler Go has different assemblers for x86, ARM, RISC-V, etc."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["You can watch this, an interesting talk about ",(0,i.jsx)(n.a,{href:"https://www.youtube.com/watch?v=KINIAgRpkDA",children:"Go Assembler"})," presented by Rob Pike himself."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://go.dev/doc/asm",children:"Go Assembler Documentation"})}),"\n",(0,i.jsx)(n.p,{children:"Go Assembler streamlined a lot of things:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Portability:"})," It abstracts CPU architecture details better."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simpler syntax:"})," No need for % prefixes, brackets, or complex addressing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unified across architectures:"})," ARM, AMD64, RISC-V, etc., use the same structure."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Designed for the Go runtime:"})," Helps implement Go features like garbage collection, goroutines, and stack growth efficiently."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Go Assembler has 4 architecture-specific implementations of ",(0,i.jsx)(n.code,{children:"atomic.CompareAndSwapInt32()"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"amd64.s"}),": For AMD64 (x86-64) architecture (Intel, AMD CPUs)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"arm64.s:"})," For ARM64 (AArch64) processors (used in Apple M1/M2, mobile devices, servers)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ppc64le.s:"})," For PowerPC 64-bit, Little Endian (used in IBM systems)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"s390x.s:"})," For IBM Z-series mainframes (used in enterprise computing)."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Go runs on multiple architectures, and low-level atomic operations must be natively implemented for each to ensure compatibility."}),"\n",(0,i.jsx)(n.p,{children:"Added the implementations for one architecture (other 3 are similar) in Go Assembly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="src/internal/runtime/atomic/atomic_amd64.s"',children:"// bool Cas(int32 *val, int32 old, int32 new)\n// Atomically:\n//\tif(*val == old){\n//\t\t*val = new;\n//\t\treturn 1;\n//\t} else\n//\t\treturn 0;\n//  }\nTEXT \xb7Cas(SB),NOSPLIT,$0-17\n\tMOVQ\tptr+0(FP), BX\n\tMOVL\told+8(FP), AX\n\tMOVL\tnew+12(FP), CX\n\tLOCK\n\tCMPXCHGL\tCX, 0(BX)\n\tSETEQ\tret+16(FP)\n\tRET\n"})}),"\n",(0,i.jsx)(n.p,{children:"Explaining this line by line how this maintains atomicity."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"TEXT \xb7Cas(SB),NOSPLIT,$0-17\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TEXT \xb7Cas(SB)"}),": Declares the function Cas(CompareAndSwap) in Go assembly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"NOSPLIT"}),": Instructs the runtime not to perform stack splitting, ensuring that the function runs without interruption. It tells the Go runtime not to perform stack splitting for that function."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$0-17:"})," Specifies the stack frame size for the function (0 bytes for local variables and 17 bytes for arguments/return values)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"MOVQ ptr+0(FP), BX:\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Moves the pointer ",(0,i.jsx)(n.code,{children:"ptr"})," (the address of val) from the function's frame pointer (FP) into the ",(0,i.jsx)(n.code,{children:"BX"})," register."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"MOVL old+8(FP), AX:\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Moves the old value from the frame pointer into the ",(0,i.jsx)(n.code,{children:"AX"})," register."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"MOVL new+12(FP), CX:\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Moves the new value from the frame pointer into the ",(0,i.jsx)(n.code,{children:"CX"})," register."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"LOCK:\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"This is a crucial instruction. It prefixes the next instruction (CMPXCHGL) with a lock, ensuring that the memory operation is atomic. This lock ensures that no other process or thread can modify the memory location while the compare and exchange instruction is running."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"CMPXCHGL CX, 0(BX):\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This is the Compare and Exchange instruction. It performs the following:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compares the value in AX (the old value) with the value at the memory location pointed to by BX (the val value)."}),"\n",(0,i.jsx)(n.li,{children:"If the values are equal, it replaces the value at 0(BX) with the value in CX (the new value)."}),"\n",(0,i.jsx)(n.li,{children:"The original value at 0(BX) is loaded into the AX register."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"SETEQ ret+16(FP):\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SETEQ sets the byte at the destination to 1 if the zero flag is set, and to 0 otherwise. In this case, it sets the return value to 1 if the comparison was equal (meaning the swap was successful), and to 0 otherwise."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"RET:\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns from the function"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"At the register level, atomicity is achieved because:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The LOCK prefix serializes access across CPU cores."}),"\n",(0,i.jsx)(n.li,{children:"CMPXCHGL ensures all three steps (compare, swap, write-back) happen as one unit."}),"\n",(0,i.jsx)(n.li,{children:"The CPU guarantees atomicity, eliminating race conditions without software locks."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Feel free to be curious and figure out the answers to your questions on your own."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},4839:e=>{e.exports=JSON.parse('{"permalink":"/prabhav.tech/blog/atomic_operations","editUrl":"https://github.com/dograprabhav/prabhav.tech/tree/master/blog/2025-02-28-atomic-operations/index.md","source":"@site/blog/2025-02-28-atomic-operations/index.md","title":"How Go atomic operations avoid race conditions?","description":"Introduction","date":"2025-02-28T00:00:00.000Z","tags":[{"inline":false,"label":"Go","permalink":"/prabhav.tech/blog/tags/go","description":"Golang exploration projects"}],"readingTime":4.29,"hasTruncateMarker":false,"authors":[{"name":"Prabhav Dogra","title":"Software Engineer II @ Blinkit","url":"https://github.com/prabhavdogra","page":{"permalink":"/prabhav.tech/blog/authors/prabhavdogra"},"socials":{"github":"https://github.com/prabhavdogra","linkedin":"https://www.linkedin.com/in/prabhav-dogra/"},"imageURL":"https://media.licdn.com/dms/image/v2/D5603AQGHJzJ1YVb_og/profile-displayphoto-shrink_800_800/B56ZS6fOAFHEAc-/0/1738295534859?e=1746057600&v=beta&t=wTqgffLNqUVaz0xEk2OUDSEvKATaSevxvWuI99mG9XY","key":"prabhavdogra"}],"frontMatter":{"slug":"atomic_operations","title":"How Go atomic operations avoid race conditions?","authors":["prabhavdogra"],"tags":["go"]},"unlisted":false,"prevItem":{"title":"Writing your own Goroutines","permalink":"/prabhav.tech/blog/diy_goroutines"},"nextItem":{"title":"Building a Ray Tracer in C++","permalink":"/prabhav.tech/blog/ray_tracer"}}')},6752:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/go_structure-7a1da1e54c9b5a7c7c73d3360e7c4c52.png"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6871],{1510:e=>{e.exports=JSON.parse('{"permalink":"/prabhav.tech/blog/sync_once","editUrl":"https://github.com/prabhavdogra/prabhav.tech/tree/master/blog/2025-04-19-sync_once_internals/index.md","source":"@site/blog/2025-04-19-sync_once_internals/index.md","title":"Digging into sync.Once: How Go Ensures One-Time Execution","description":"How it started?","date":"2025-04-19T00:00:00.000Z","tags":[{"inline":false,"label":"Go","permalink":"/prabhav.tech/blog/tags/go","description":"Golang exploration projects"}],"readingTime":6.95,"hasTruncateMarker":false,"authors":[{"name":"Prabhav Dogra","title":"Software Engineer II @ Blinkit","url":"https://github.com/prabhavdogra","page":{"permalink":"/prabhav.tech/blog/authors/prabhavdogra"},"socials":{"github":"https://github.com/prabhavdogra","linkedin":"https://www.linkedin.com/in/prabhav-dogra/"},"imageURL":"https://media.licdn.com/dms/image/v2/D5603AQGHJzJ1YVb_og/profile-displayphoto-shrink_800_800/B56ZS6fOAFHEAc-/0/1738295534859?e=1746057600&v=beta&t=wTqgffLNqUVaz0xEk2OUDSEvKATaSevxvWuI99mG9XY","key":"prabhavdogra"}],"frontMatter":{"slug":"sync_once","title":"Digging into sync.Once: How Go Ensures One-Time Execution","authors":["prabhavdogra"],"tags":["go"]},"unlisted":false,"nextItem":{"title":"What does memory mean actually?","permalink":"/prabhav.tech/blog/memory_hierarchy"}}')},8453:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>l});var i=o(6540);const t={},s=i.createContext(t);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(s.Provider,{value:n},e.children)}},8659:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});var i=o(1510),t=o(4848),s=o(8453);const c={slug:"sync_once",title:"Digging into sync.Once: How Go Ensures One-Time Execution",authors:["prabhavdogra"],tags:["go"]},l=void 0,r={authorsImageUrls:[void 0]},a=[{value:"How it started?",id:"how-it-started",level:3},{value:"Prerequisites: What&#39;s sync.Once?",id:"prerequisites-whats-synconce",level:3},{value:"Digging into sync.Once internals?",id:"digging-into-synconce-internals",level:2},{value:"Internals (Go 1.18)",id:"internals-go-118",level:3},{value:"Internals (Go 1.24)",id:"internals-go-124",level:3},{value:"&quot;noCopy&quot; What&#39;s that?",id:"nocopy-whats-that",level:4},{value:"Regular uint32 vs. atomic.Uint32",id:"regular-uint32-vs-atomicuint32",level:4},{value:"Bonus: Go. 1.25 (Hopefully)",id:"bonus-go-125-hopefully",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h3,{id:"how-it-started",children:"How it started?"}),"\n",(0,t.jsxs)(n.p,{children:["While writing some concurrent code for ",(0,t.jsx)(n.a,{href:"https://blinkit.com/",children:"Blinkit"}),", I found myself reaching for ",(0,t.jsx)(n.code,{children:"sync.Once"}),"\u2014a common utility in Go to ensure an action is performed just once, no matter how many goroutines attempt it. Out of curiosity, I decided to dig into how ",(0,t.jsx)(n.code,{children:"sync.Once"})," works internally and how its implementation has evolved over time. While investigating the internals I came across something interesting and ended up contributing myself \u2014 a small step, but super rewarding!"]}),"\n",(0,t.jsxs)(n.p,{children:["In this blog, I\u2019ll walk through the internals of ",(0,t.jsx)(n.code,{children:"sync.Once"}),", how it leverages atomics for performance, and trace its evolution through Go versions. This blog is meant to motivate you to explore and solve your own doubts by diving into the source code of Go itself. You\u2019ll be amazed at how much you can learn just by following the code and seeing how things work behind the scenes!"]}),"\n",(0,t.jsx)(n.h3,{id:"prerequisites-whats-synconce",children:"Prerequisites: What's sync.Once?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"sync.Once"})," ensures a function is only executed once, no matter how many times it's called, even across goroutines."]}),"\n",(0,t.jsx)(n.li,{children:"It's most commonly used to initialize shared resources like config, DB connections, or singletons."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"var (\n\treadConfigOnce  sync.Once\n\tconfig          *Config\n)\n\nfunc GetConfig() (c *Config) {\n\treadConfigOnce.Do(func() {\n\t\t// Read yaml and make config object\n\t})\n\treturn config\n}\n\nfunc main() {\n\tcfg := LoadConfig()\n\tfmt.Println(cfg)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Link to ",(0,t.jsx)(n.a,{href:"https://pkg.go.dev/sync#Once.Do",children:"sync.Once documentation"})]}),"\n",(0,t.jsx)(n.h2,{id:"digging-into-synconce-internals",children:"Digging into sync.Once internals?"}),"\n",(0,t.jsxs)(n.p,{children:["To follow along this read feel free to clone the ",(0,t.jsx)(n.a,{href:"https://github.com/golang/go",children:"Golang"})," repository."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Open the repository and run the bash script ",(0,t.jsx)(n.code,{children:"./make.bash"}),", to build and install the latest compiler of Go."]}),"\n",(0,t.jsx)(n.li,{children:"Point your system or editor (like VSCode) to use the newly built Go version:"}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{title:"Bootstrapped Compilers",type:"note",children:[(0,t.jsx)(n.p,{children:"When I first came across the concept of a bootstrapped compiler, it honestly felt like a total brain teaser. The idea that a compiler could be written in the same language it\u2019s supposed to compile? Wild."}),(0,t.jsxs)(n.p,{children:["Here\u2019s the bombshell: ",(0,t.jsx)(n.strong,{children:"the Go compiler is written in Go itself"}),".\nSounds paradoxical, right?"]}),(0,t.jsxs)(n.p,{children:["Like a classic chicken-and-egg dilemma -\n",(0,t.jsx)(n.strong,{children:"\u201cHow can a compiler compile itself if it doesn\u2019t exist yet?\u201d"})]}),(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"In programming, bootstrapping refers to:\nThe process of building a system using a simpler or initial version of itself."}),"\n"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"make.bash"})," is a shell script located at ",(0,t.jsx)(n.code,{children:"src/make.bash"})," inside the Go source tree."]}),"\n",(0,t.jsxs)(n.li,{children:["It's used to bootstrap the Go toolchain \u2014 it builds the Go compiler (",(0,t.jsx)(n.code,{children:"cmd/compile"}),"), linker (",(0,t.jsx)(n.code,{children:"cmd/link"}),"), and other core tools from scratch using the Go bootstrap toolchain."]}),"\n",(0,t.jsx)(n.li,{children:"It uses the already installed Go compiler"}),"\n",(0,t.jsx)(n.li,{children:"Use the clones Golang source code to build the new version of Go."}),"\n"]})]}),"\n",(0,t.jsx)(n.h3,{id:"internals-go-118",children:"Internals (Go 1.18)"}),"\n",(0,t.jsxs)(n.p,{children:["Let's start from the basics, struct of ",(0,t.jsx)(n.code,{children:"sync.Once"})," looks like"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",metastring:'title="src/sync/once.go | GOVERSION=1.18"',children:"type Once struct {\n\tdone uint32\n\tm    Mutex\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Pretty simple, right?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["One ",(0,t.jsx)(n.code,{children:"uint32"})," flag ",(0,t.jsx)(n.code,{children:"done"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"done == 1"})," means that the function has ran once"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"done == 0"})," means that the function hasn't ran yet"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["One mutex ",(0,t.jsx)(n.code,{children:"m"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A mutex to avoid race condition while updating ",(0,t.jsx)(n.code,{children:"done"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Ok, somehow these two are used together to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ensure that a particular action executes only once, regardless of how many times it is called concurrently."}),"\n",(0,t.jsx)(n.li,{children:"Achieve this guarantee efficiently, minimizing lock contention for better performance."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Ok so far so good right?"}),"\n",(0,t.jsxs)(n.p,{children:["Let's move to the implementation of ",(0,t.jsx)(n.code,{children:"once.Do(f)"}),": It ensures that the function ",(0,t.jsx)(n.code,{children:"f()"})," is only executed once, no matter how many times it's called\u2014even if from multiple goroutines."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",metastring:'title="src/sync/once.go | GOVERSION=1.18"',children:"func (o *Once) Do(f func()) {\n\tif atomic.LoadUint32(&o.done) == 0 {\n\t\to.doSlow(f)\n\t}\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Goal:"})," Avoid acquiring a mutex unless absolutely necessary (i.e., the function ",(0,t.jsx)(n.code,{children:"f()"})," hasn\u2019t run yet)."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"if atomic.LoadUint32(&o.done) == 0"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We check if ",(0,t.jsx)(n.code,{children:"done == 0"}),", ",(0,t.jsx)(n.code,{children:"done == 0"})," means that the function hasn't ran yet"]}),"\n",(0,t.jsxs)(n.li,{children:["It checks ",(0,t.jsx)(n.code,{children:"done == 0"})," atomically in one operation. More about ",(0,t.jsx)(n.a,{href:"https://prabhavdogra.github.io/prabhav.tech/blog/atomic_operations",children:(0,t.jsx)(n.code,{children:"atomic package"})})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (o *Once) doSlow(f func()) {\n\to.m.Lock()\n\tdefer o.m.Unlock()\n\tif o.done == 0 {\n\t\tdefer atomic.StoreUint32(&o.done, 1)\n\t\tf()\n\t}\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"if o.done == 0"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A second check inside the locked section."}),"\n",(0,t.jsx)(n.li,{children:"Why? Because multiple goroutines might pass the atomic check in Do(), but only one should actually run the function. So we check again inside the lock to be 100% sure."}),"\n",(0,t.jsx)(n.li,{children:"This is a double-checked locking pattern."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"defer atomic.StoreUint32(&o.done, 1)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Marks the function as executed after ",(0,t.jsx)(n.code,{children:"f()"})," is done."]}),"\n",(0,t.jsxs)(n.li,{children:["It\u2019s deferred so even if ",(0,t.jsx)(n.code,{children:"f()"})," panics, we still consider it \u201cdone\u201d and don't call it again (intentional in Go\u2019s design)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"internals-go-124",children:"Internals (Go 1.24)"}),"\n",(0,t.jsxs)(n.p,{children:["In newer versions of Go they revised the implementation of how ",(0,t.jsx)(n.code,{children:"sync.Once"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",metastring:'title="src/sync/once.go | GOVERSION=1.24"',children:"type Once struct {\n\t_ noCopy\n\tdone atomic.Uint32\n\tm    Mutex\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Ok!\nWhat's changed now?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"noCopy"})," is embedded in ",(0,t.jsx)(n.code,{children:"Once"})," struct"]}),"\n",(0,t.jsxs)(n.li,{children:["done is ",(0,t.jsx)(n.code,{children:"atomic.Uint32"})," not ",(0,t.jsx)(n.code,{children:"uint32"})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"nocopy-whats-that",children:'"noCopy" What\'s that?'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It'a a zero-size struct that is adds no memory overhead."}),"\n",(0,t.jsxs)(n.li,{children:["Go has a statical analysis tool ",(0,t.jsx)(n.code,{children:"go vet"})," that checks your Go source code for common mistakes and suspicious constructs that the compiler won\u2019t catch."]}),"\n",(0,t.jsxs)(n.li,{children:["Some types must never be copied once they\u2019ve been initialized\u2014most notably synchronization primitives like ",(0,t.jsx)(n.code,{children:"sync.Mutex"}),", ",(0,t.jsx)(n.code,{children:"sync.Once"}),", etc. Accidental copies can lead to deadlocks or data races."]}),"\n",(0,t.jsxs)(n.li,{children:["Having ",(0,t.jsx)(n.code,{children:"noCopy"})," embedded in your struct will produce a warning if your type is ever copied by ",(0,t.jsx)(n.code,{children:"go vet"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"regular-uint32-vs-atomicuint32",children:"Regular uint32 vs. atomic.Uint32"}),"\n",(0,t.jsx)(n.p,{children:"When you don't know something in Go let's follow the approach like we have done, and let's look at the source code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",metastring:'title="src/atomic/type.go | GOVERSION=1.24"',children:"type Uint32 struct {\n\t_ noCopy\n\tv uint32\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Ok, wow! As you can see ",(0,t.jsx)(n.code,{children:"atomic.Uint32"})," is just a wrapper type around a uint32 with ",(0,t.jsx)(n.code,{children:"noCopy"})," but why???"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Let's look further functions binded to this struct:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Load atomically loads and returns the value stored in x.\nfunc (x *Uint32) Load() uint32 { return LoadUint32(&x.v) }\n\n// Store atomically stores val into x.\nfunc (x *Uint32) Store(val uint32) { StoreUint32(&x.v, val) }\n\n// Swap atomically stores new into x and returns the previous value.\nfunc (x *Uint32) Swap(new uint32) (old uint32) { return SwapUint32(&x.v, new) }\n\n// CompareAndSwap executes the compare-and-swap operation for x.\nfunc (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool) { return CompareAndSwapUint32(&x.v, old, new) }\n"})}),"\n",(0,t.jsx)(n.p,{children:"Ok, seems like it's just a wrapper type provides methods for atomic operations."}),"\n",(0,t.jsxs)(n.p,{children:["And that is exactly what ",(0,t.jsx)(n.code,{children:"atomic.Uint32"})," is:"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"A Go\xa01.19+ wrapper type around a uint32 that provides methods for atomic operations"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"bonus-go-125-hopefully",children:"Bonus: Go. 1.25 (Hopefully)"}),"\n",(0,t.jsxs)(n.p,{children:["While exploring the internals of ",(0,t.jsx)(n.code,{children:"sync.Once"}),", I noticed that the done field \u2014 which indicates whether the function has already been executed \u2014 was originally an ",(0,t.jsx)(n.code,{children:"atomic.Uint32"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["However, since it\u2019s only ever used as a boolean flag (0 or 1), I realized it could be more semantically clear to use ",(0,t.jsx)(n.code,{children:"atomic.Bool"})," instead. Even though atomic.Bool is just a thin wrapper around a uint32 under the hood, switching to it makes the code more self-explanatory and aligns better with the intent of the field.\nSo I decided to raise a PR and it got merged ",(0,t.jsx)(n.code,{children:":)"})]}),"\n",(0,t.jsx)(n.p,{children:"Now the struct looks like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",metastring:'title="src/sync/once.go | GOVERSION=1.25"',children:"type Once struct {\n\t_ noCopy\n\tdone atomic.Bool\n\tm    Mutex\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["Exploring ",(0,t.jsx)(n.code,{children:"sync.Once"})," from ",(0,t.jsx)(n.strong,{children:"Go\xa01.18"})," to ",(0,t.jsx)(n.strong,{children:"Go\xa01.24"})," shows how a small, fundamental primitive can evolve for clarity, safety, and maintainability:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Go\xa01.18"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Used a plain uint32 flag plus a Mutex and double\u2011checked locking"}),"\n",(0,t.jsx)(n.li,{children:"Minimized lock contention by atomically checking the flag on the fast path"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Go\xa01.24"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Embeds ",(0,t.jsx)(n.code,{children:"noCopy"})," to catch accidental copies via go vet"]}),"\n",(0,t.jsxs)(n.li,{children:["Switches to ",(0,t.jsx)(n.code,{children:"atomic.Uint32"}),", providing a clean, method\u2011based API"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Go\xa01.25"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Switches ",(0,t.jsx)(n.code,{children:"atomic.Uint32"})," to ",(0,t.jsx)(n.code,{children:"atomic.Bool"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Along the way we\u2019ve seen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bootstrapping"})," \u2013 how Go builds itself from source via make.bash"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Atomic vs. mutex"})," \u2013 why lock\u2011free fast paths matter in high\u2011concurrency code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Static analysis"})," \u2013 how noCopy and go vet help prevent subtle bugs"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The beauty of Go\u2019s standard library is that it balances performance, safety, and readability. Whenever you have a question about how Go works under the hood, the answer is just a GitHub clone and a make.bash away. Dive into the source, follow the code, and you\u2019ll not only solve your doubts\u2014you\u2019ll discover deeper principles that make Go such a pleasure to work with."}),"\n",(0,t.jsx)(n.p,{children:"And it\u2019s downright fun to see how these technologies evolve over time."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);